\documentclass{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\input{macros/preamble}
\input{macros/macros}
\input{macros2}

%-------------- template --------------------------------------------------
\usetheme{metropolis}
\metroset{block=fill}
%\usetheme{Boadilla}
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.5\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertsection
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.1\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother
\setbeamertemplate{navigation symbols}{}

%----------------------------------------------------------------------------
\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
%------ using xy ------------------------------------------------------------
\usepackage[all]{xy}
%\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _-{#2} }}
\def\larrow#1#2#3{\xymatrix{ #3 & #1 \ar[l] _--{#2} }}
\def\rarrow#1#2#3{\xymatrix{ #1 \ar[r]^-{#2} & #3 }}
\def\arLaw#1#2#3#4#5{
\xymatrix{
        #1      \ar@/^1pc/[rr]^-{#4} &
        #5 &
        #2      \ar@/^1pc/[ll]^-{#3}
}}
\def\arLeq#1#2#3#4{\arLaw{#1}{#2}{#3}{#4}\leq}
%------ using pstricks (rnode etc) ------------------------------------------
\usepackage{pstricks,pst-node,pst-text,pst-3d}
%------ using color ---------------------------------------------------------

\newrgbcolor{goldenrod}{.80392 .60784 .11373}
\newrgbcolor{darkgoldenrod}{.5451 .39608 .03137}
\newrgbcolor{brown}{.15 .15 .15}
\newrgbcolor{darkolivegreen}{.33333 .41961 .18431}
%
%
\def\gold#1{{\goldenrod #1}}
% \def\dgold#1{{\darkgoldenrod #1}}
\def\dgold#1{{\alert{#1}}}
%\def\brw#1{{\brown #1}}
\def\dkb#1{{\blue #1}}
\def\tdkb#1{\textbf{\darkblue #1}}
%%\def\gre#1{{\green #1}}
\def\gre#1{{\darkolivegreen #1}}
\def\gry#1{{\gray #1}}
\def\rdb#1{{\red #1}}
\def\st{\mathbf{.}\,}
\def\laplace#1#2{*\txt{\mbox{ \fcolorbox{black}{myGray}{$\begin{array}{c}\mbox{#1}\\\\#2\\\\\end{array}$} }}}
%\newcommand{\galois}[2]{#1\; \dashv\; #2}

\def\eqm{\mathbin{\equiv}}                     
\def\noeqm{\mathbin{\not\!\equiv}}  
%\newcommand{\flam}[2]{\lambda_{#1}\; .\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\existencial#1#2{\exists_{#1}\;.\; #2}

\def\pv#1#2{\langle #1 \rangle #2}
\def\nc#1#2{[#1]#2}
\def\pvo#1#2{\langle \! \! \! \langle #1 \rangle \! \! \! \rangle\, #2}
\def\nco#1#2{\llbracket #1 \rrbracket #2}
\def\cvg#1{\llbracket \downarrow \rrbracket #1}
\def\cvgr#1#2{\llbracket #1 \downarrow \rrbracket #2}
\def\cvgl#1#2{\llbracket \downarrow  #1 \rrbracket #2}
\def\cvglr#1#2{\llbracket \downarrow  #1 \downarrow \rrbracket #2}
\def\lfp#1#2{\mu {#1}\, .\, {#2}}
\def\lpf#1#2{\mu {#1}\, .\, {#2}}
\def\gfp#1#2{\nu {#1}\, .\, {#2}}
\def\gpf#1#2{\nu {#1}\, .\, {#2}}
\def\mset#1{\vvv #1 \vvv}
\def\vvv{\vert \! \vert}
\def\mnc#1{\vvv [#1] \vvv}
\def\mpv#1{\vvv \langle #1 \rangle \vvv}
\def\bcomp#1{#1^{\text{c}}}
\def\eqm{\mathbin{\simeq}}
\def\noeqm{\mathbin{\not\!\simeq}}
\def\universal#1#2{\forall_{#1}\;.\; #2}
\def\existential#1#2{\exists_{#1}\;.\; #2}
\def\oexistential#1#2{\exists^{1}_{#1}\;.\; #2}
\def\MM{\mathcal{M}}
\def\uppaal{\textsc{Uppaal}}
\def\cc#1{\mathcal{C}(#1)}
\def\R{\mathcal{R}}
\def\TL#1{\mathcal{T}(#1)}
\def\HL#1{\mathcal{H}(#1)}
\def\ET#1{\mathsf{ExecTime(#1)}}
\newcommand\mdoubleplus{\mathbin{+\mkern-10mu+}}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}

% context
\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}
\author[Renato Neves]{Renato Neves}

% logos of institutions
\titlegraphic{
  \begin{textblock*}{5cm}(6.7cm,7.57cm)
     \includegraphics[scale=0.05525]{./images/uminho.png}
  \end{textblock*}
  \begin{textblock*}{5cm}(9.4cm,7.57cm)
    \includegraphics[scale=0.50]{./images/haslab.pdf}
  \end{textblock*}
}

% No date
\date{}


\begin{document}

\title{Simply Typed Lambda-calculus}

\frame[plain]{\titlepage}

\section{The Calculus} 

\begin{frame}{Deductive Reasoning}

  \begin{block}{The essence}
          Knowledge obtained via \alert{\underline{assumptions}} and
          \alert{\underline{logical rules}}
  \end{block}

  \pause
  \bigskip
  Studied since Aristotle  \dots

  \dots \, long before the age of \alert{\underline{artificial}} computers

  What does it have to do with programming ?
\end{frame}

\begin{slide}{A Basic Deductive System}
  \begin{minipage}[0.3\textheight]{\textwidth}
  \begin{columns}[c]
  \begin{column}{0.5\textwidth}
          $\typeA,\typeB \dots$ denote \alert{\underline{propositions}}
          and $\typeOne$ a proposition that always holds   
  \end{column}
  \begin{column}{0.45\textwidth}
        \includegraphics[scale=0.2]{images/gentzen.jpg}
        \includegraphics[scale=0.16]{images/prawitz.jpg}
  \end{column}
  \end{columns}
  \end{minipage}

  If $\typeA$ and $\typeB$ are propositions then
  \begin{itemize}
    \item $\typeA \times \typeB$ is a proposition -- 
        conjunction of $\typeA$ and $\typeB$
    \item $\typeA \to \typeB$ is a proposition -- 
            implication of $\typeB$ from $\typeA$
  \end{itemize}
  
\end{slide}

\begin{frame}{A Basic Deductive System}
  
  $\Gamma$ denotes a \alert{\underline{list of propositions}} (often called context)

  $\Gamma \vljud \typeA$ reads \emph{``if the propositions in $\Gamma$ hold then  $\typeA$ also holds''}

  \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud \typeA}{\typeA \in \Gamma} \hspace{0.8cm}
      \infer[(\rulename{trv})]{\Gamma \vljud  1}{}  \hspace{0.8cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \typeA}{\Gamma \vljud \typeA \times \typeB} \hspace{0.8cm}
      \infer[(\rulename{\pi_2})]{\Gamma \vljud \typeB}{\Gamma \vljud \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
      \infer[(\rulename{prd})]{\Gamma \vljud \typeA \times \typeB}
      {\Gamma \vljud \typeA \qquad \Gamma \vljud \typeB} \hspace{0.4cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \typeA \to \typeB}{\Gamma, \typeA \vljud  \typeB}
      \hspace{0.4cm}
      \infer[(\rulename{app})]{\Gamma \vljud \typeB}
      {\Gamma \vljud  \typeA \to \typeB \quad
        \Gamma \vljud  \typeA}
  \end{flalign*}
        } 
  
  \bigskip
  \begin{block}{Exercise}
        Show that $\typeA \times \typeB \vdash \typeB \times \typeA$
  \end{block}
 
\end{frame}

\begin{slide}{New Knowledge From Old}
  The rules below are \alert{\underline{derivable}} from the previous system

  \begin{flalign*}
      \infer[\text{(exchange)}]{\Gamma, \typeB, \typeA,\Delta \vljud \typeC}{
      \Gamma, \typeA, \typeB,\Delta \vljud \typeC}
      \hspace{2cm}
      \infer[\text{(weakening)}]{\Gamma,\typeB \vljud \typeA}{\Gamma \vljud \typeA}
  \end{flalign*}
  \begin{flalign*}
      \infer[\text{(cut elimination)}]{\Gamma\vljud \typeB}{
      \Gamma, \typeA \vljud \typeB \qquad \Gamma \vljud \typeA}
  \end{flalign*}

  Proofs (again) by an appeal to your old friend \dots\  \alert{\underline{induction}} :-)
\end{slide}

\begin{frame}{Exercises}
  Derive the following judgements
  \begin{itemize}
          \item $\typeA \to \typeB,\typeB \to \typeC \vljud \typeA \to \typeC$ 
          \item $\typeA \to \typeB,\typeA \to \typeC \vljud \typeA \to \typeB
                  \times \typeC$
  \end{itemize}        
\end{frame}

\begin{frame}[plain]

        \begin{center}
                Back to programming \dots
        \end{center}
\end{frame}
\begin{slide}{The Bare Essentials of Programming}
  We should think of
  what are the \alert{\underline{basic features}} of programming \dots
  \begin{itemize}
  \item variables  
  \item function application and creation
  \item pairing \dots
  \end{itemize}
  and base our study on the \alert{\underline{simplest language}} with
  such features \dots
  \caixa{
    \begin{center}
        Simply-typed $\lambda$-calculus
    \end{center}
  }
  \vfill
  The basis of \alert{\texttt{\underline{Haskell}}}, \texttt{ML},
  \texttt{Eff}, \texttt{F\#}, \texttt{Agda}, \texttt{Elm} and many
  other programming languages
\end{slide}

\begin{frame}{Simply-typed $\lambda$-Calculus}

  Types are defined by $\typeA ::= \typeOne \mid \typeA \times \typeA \mid \typeA
  \to \typeA$

  $\Gamma$ now a \alert{\underline{non-repetitive}} list of typed variables
  ($x_1 : \typeA_1 \dots x_n : \typeA_n$)

  Programs built according to the following \alert{\underline{deduction rules}}

  \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud x : \typeA}{x :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[(\rulename{triv})]{\Gamma \vljud \ast : 1}{}  \hspace{1.2cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \pi_1 \, t : \typeA }
      {\Gamma \vljud t: \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
     \infer[(\rulename{prd})]{\Gamma \vljud \langle t,s \rangle :
        \typeA \times \typeB}
      {\Gamma \vljud t: \typeA \qquad \Gamma \vljud s: \typeB} \hspace{1cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \lambda x : \typeA . \, t : \typeA
        \to \typeB}
      {\Gamma, x : \typeA \vljud t : \typeB}
    \end{flalign*}
   \begin{flalign*}
      \infer[(\rulename{app})]{\Gamma \vljud t \, s : \typeB}
      {\Gamma \vljud  t : \typeA \to \typeB \quad
        \Gamma \vljud  s : \typeA}
    \end{flalign*}
   }
\end{frame}

\begin{slide}{Examples of $\lambda$-terms}
  \begin{flalign*}
          & x : \typeA \vljud x : \typeA && \text{(identity)}
          \\[15pt]
          & x : \typeA \vljud \langle x, x \rangle : \typeA \times \typeA
          && \text{(duplication)} 
          \\[15pt]
          & x : \alert{\typeA \times \typeB}
          \vljud \langle \pi_2\ x , \pi_1\ x \rangle : \alert{ \typeB \times \typeA }
          && \text{(swap)}
          \\[15pt]
          & f : \alert{\typeA \to \typeB}, g : \alert{\typeB \to \typeC} \vljud
          \lambda x : \typeA . \> g (f \> x) : \alert{\typeA \to \typeC}
          && \text{(composition)}
  \end{flalign*}
\end{slide}

\begin{frame}{Exercises}

    Recall the derivations that lead to the judgement
    \[
      \typeA \to \typeB,  \typeA \to \typeC \vljud  \typeA 
      \to \typeB \times \typeC
    \]
    Build the corresponding program

    \bigskip
    Derive as well the judgement 
    \[
        \typeA \to \typeB \vljud  \typeA  \times \typeC
        \to \typeB \times \typeC
    \]
    and subsequently build the corresponding program
\end{frame}

\section{Denotational Semantics}

\begin{slide}{A Semantics for Simply Typed $\lambda$-calculus}
  We wish to assign a \alert{\underline{mathematical meaning}} to $\lambda$-terms
  \begin{flalign*}
    \sem{-} \, : \lambda\text{-terms} \longrightarrow ...
  \end{flalign*}
  so that we can reason about them rigorously, and take advantage
  of known mathematical theories
  \vfill \pause
  
  This is the goal of the next slides. But first \dots
\end{slide}

\begin{slide}{Functions: Basic Facts}

  For every set $X$ there exists a `trivial' function
  \begin{flalign*}
    ! : X \longrightarrow \{ \star \} = 1 \hspace{1cm} ! \, (x) = \star
  \end{flalign*}

  We can always pair two functions into
  $f : X \to A$, $g : X \to B$
  \begin{flalign*}
    \pv{f,g} : X \to A \times B \hspace{1cm} \pv{f,g}(x) = (f \> x, g \> x)
  \end{flalign*}

  There exist projection functions
  \begin{flalign*}
    \pi_1 : X \times Y \to X  \hspace{1cm} \pi_1(x,y) = x \\
    \pi_2 : X \times Y \to Y  \hspace{1cm} \pi_2(x,y) = y
  \end{flalign*}
\end{slide}

\begin{slide}{Functions: Basic Facts}

  We can always `curry' a function $f : X \times Y \to Z$ into
  \begin{flalign*}
    \lambda f : X \to Z^Y \hspace{1cm} \lambda f (x) = (y \mapsto f(x,y))
  \end{flalign*}

  Consider sets $X,Y, Z$. There exists an application function
  \begin{flalign*}
    \mathrm{app} : Z^Y  \times Y \to Z \hspace{1cm}
    \mathrm{app}(f,y) = f \> y
  \end{flalign*}
\end{slide}

\begin{slide}{Denotational Semantics}
  Types $\typeA$ interpreted as \alert{\underline{sets}} $\sem{\typeA}$
  \begin{flalign*}
    \sem{1} & = \{ \star \} \\
    \sem{\typeA \times \typeB} & = \sem{\typeA} \times \sem{\typeB} \\
   \sem{\typeA \to \typeB} & = \sem{\typeB}^{\sem{\typeA}} 
 \end{flalign*}

 Typing contexts $\Gamma$ interpreted as Cartesian products
 \begin{flalign*}
  \sem{\Gamma}\ = \sem{x_1 : \typeA_1, \dots, x_n : \typeA_n}\ =
 \sem{\typeA_1} \times \dots \times \sem{\typeA_n} 
 \end{flalign*}

 $\lambda$-terms $\Gamma \vljud t : \typeA$ interpreted as \alert{\underline{functions}}
 \begin{flalign*}
   \sem{\Gamma \vljud t : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}

\end{slide}

\begin{slide}{Denotational Semantics}
  $\lambda$-term $\Gamma \vljud t : \typeA$ interpreted as a function
 \begin{flalign*}
   \sem{\Gamma \vljud t : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}
 \vspace{-0.5cm}
 \small{
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud x_i : \typeA} = \pi_i}{x_i :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \ast : 1}\ =\ !}{}  \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \pi_1 t : \typeA} = \pi_1 \comp f }
      {\sem{\Gamma \vljud t : \typeA \times \typeB} = f}
  \end{flalign*}
  \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud \langle t,s \rangle :
        \typeA \times \typeB}\ = \pv{f,g}}
    {\sem{\Gamma \vljud t: \typeA}\ = f \qquad \sem{\Gamma \vljud s: \typeB}\ = g}
    \hspace{0.3cm}
     \infer[]{\sem{\Gamma \vljud \lambda x : \typeA . \, t : \typeA
        \to \typeB}\ = \lambda f}
      {\sem{\Gamma, x : \typeA \vljud t : \typeB}\ = f}
    \end{flalign*}
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud t \, s : \typeB}\ = \mathrm{app} \comp \pv{f,g}}
      {\sem{\Gamma \vljud  t : \typeA \to \typeB}\ = f \quad
        \sem{\Gamma \vljud  s : \typeA}\ = g}
    \end{flalign*}
}
\end{slide}

\begin{frame}{The Unravelling}
        \begin{align*}
                & \sem{x \vljud \pv{ \pi_2 \, x, \, \pi_1 \, x} } &  = \dots 
                &
                \\
                & \sem{- \vljud \lambda x. \, \pv{ \pi_2 \, x, \, \pi_1 \, x} } & = \dots 
                &
                \\[10pt]
                & \sem{f, g , x \vljud g \, f \, x} & = \dots
                &
                \\
                & \sem{f, g \vljud \lambda x. \, g \, f \, x} & = \dots
                &
                \\[10pt]
                & \sem{f, x \vljud \pv{f \, \pi_1 \, x, \, \pi_2 \, x} \, } & = \dots
                &
                \\
                & \sem{f \vljud \lambda x. \, \pv{f \, \pi_1 \, x, \, \pi_2 \, x} \, } & = \dots
                &
                \\
                & \sem{- \vljud \lambda f. \, \lambda x. \, \pv{f \, \pi_1 \,
                x, \, \pi_2 \, x} \, } & = \dots &
        \end{align*}
        \vfill
        \begin{center}
                (\scriptsize{\textbf{N.B.} all types omitted for simplicity})
        \end{center}
\end{frame}
\begin{slide}{Denotational Semantics and Equivalence Revisited}
  Show that the following equations hold
  \begin{flalign*}
    \sem{x, y \vljud \pi_1 \pv{x,y}}\ & =\
    \sem{x , y \vljud x } \\[5pt]
    \sem{\Gamma \vljud t}\ & =\
    \sem{\Gamma \vljud \langle \pi_1\ t, \pi_2\ t \rangle }
    \\[5pt]
    \sem{ x \vljud (\lambda y. \, \pv{x,y})\>  \> x  }\,
                                    & =\
                                    \sem{ x \vljud \pv{x,x}  }
  \end{flalign*}

  \pause
  Show that the (complicated) $\lambda$-term below is really just the identity
  \begin{align*}
    z \vljud \lambda x. \, \pv{\pi_2 \, x, \pi_1 \, x}\>
    \Big (\lambda y. \, \pv{\pi_2 \, y, \pi_1 \, y} \> z \Big ) 
  \end{align*}

  \pause
  \textbf{ Hard ? }
\end{slide}

\section{Equational System}
\begin{slide}{Logic to the Rescue ! }
  Recall that the rules below are \alert{\underline{derivable}} from  our logical system

  \begin{flalign*}
      \infer[\text{(exchange)}]{\Gamma, \typeB, \typeA,\Delta \vljud \typeC}{
      \Gamma, \typeA, \typeB,\Delta \vljud \typeC}
      \hspace{2cm}
      \infer[\text{(weakening)}]{\Gamma,\typeB \vljud \typeA}{\Gamma \vljud \typeA}
  \end{flalign*}
  \begin{flalign*}
      \infer[\text{(cut elimination)}]{\Gamma\vljud \typeB}{
      \Gamma, \typeA \vljud \typeB \qquad \Gamma \vljud \typeA}
  \end{flalign*}
\end{slide}

\begin{slide}{Via the Programming Lens}
  \begin{flalign*}
      \infer[\text{(exch)}]{\Gamma, y: \typeB, x: \typeA,\Delta \vljud t: \typeC}{
      \Gamma, x : \typeA, y : \typeB,\Delta \vljud t: \typeC}
      \hspace{2cm}
      \infer[\text{(weak)}]{\Gamma, x : \typeB \vljud t : \typeA}{\Gamma \vljud t : \typeA}
  \end{flalign*}
  \begin{flalign*}
      \infer[\text{(cut elimination)}]{\Gamma\vljud \dots :\typeB}{
      \Gamma, x: \typeA \vljud t: \typeB \qquad \Gamma \vljud s : \typeA}
  \end{flalign*}
  
  \pause
  \bigskip
  \begin{center}
  Filling up the dots will lead us to a fundamental concept
  \end{center}
  
  \pause
  \begin{center}
  \fbox{
          \alert{\underline{Substitution}}
  }
  \end{center} 
\end{slide}

\begin{frame}{Substitution}
        \begin{block}{The essence}
                Substitution of variables in a  $\lambda$-term $t$ by another
                $\lambda$-term $s$
        \end{block}

        $t[s/x]$ reads \emph{"replace every occurrence of $x$ in $t$ by $s$"}

        \pause
        \bigskip
        \begin{example}
                \vspace{-0.5cm}
                \begin{align*}
                        \pv{x,x}[s/x] & = \pv{s,s}
                        \\
                        \pv{x,y}[s/x] & = \pv{s,y}
                        \\
                        \pv{y,z}[s/x] & = \pv{y,z}
                \end{align*}
                \vspace{-0.7cm}
        \end{example}
\end{frame}

\begin{frame}{Substitution More Formally}

        We define it by \alert{\underline{induction}}
        \begin{align*}
                x[s/y] & = 
                \begin{cases}
                        s & \text{if } x = y \\
                        x & \text{otherwise}
                \end{cases}
                \\
                \ast[s/y] & = \ast
                \\
                \pv{t_1,t_2}[s/y] & = \pv{t_1[s/y], t_2[s/y]}
                \\
                (t_1 \, t_2)[s/y] & = t_1[s/y] \> t_2[s/y]
                \\
                (\pi_1 t)[s/y] & = \pi_1 t[s/y] 
                \\
                (\pi_2 t)[s/y] & = \pi_2 t[s/y] 
                \\
                (\lambda x. \, t)[s/y] & = \, \dots
        \end{align*}
\end{frame}

\begin{frame}{Variable Captures}

        $\lambda x. \, y$ is a ``constant function" (given $x$ return $y$)

        \pause
        $(\lambda x. \, y)[z/y]$ is still a ``constant function" (given $x$ return $z$)

        \pause
        $(\lambda x. \, y) [x/y]$ is now the identity !?

        \pause
        \bigskip
        \bigskip
        \alert{\underline{The problem:}} variable $x$ "captured" by the construct "$\lambda x. \,$"

        Somehow similar to \alert{\underline{variable shadowing}} in programming
\end{frame}

\begin{frame}{Substitution More Formally}
        \begin{align*}
                x[s/x] & = 
                \begin{cases}
                        s & \text{if } x = y \\
                        x & \text{otherwise}
                \end{cases}
                \\
                \ast[s/y] & = \ast
                \\
                \pv{t_1,t_2}[s/y] & = \pv{t_1[s/y], t_2[s/y]}
                \\
                (t_1 \, t_2)[s/y] & = t_1[s/y] \> t_2[s/y]
                \\
                (\pi_1 \, t)[s/y] & = \pi_1 \, t[s/y] 
                \\
                (\pi_2 \, t)[s/y] & = \pi_2 \, t[s/y] 
                \\
                (\lambda x. \, t)[s/y] & = 
                        \lambda z. \, t[z/x][s/y]
        \end{align*}

        \begin{center}
                (where $z$ is \alert{\underline{fresh}} (\emph{i.e.} new))
        \end{center}
\end{frame}

\begin{frame}{Exercise}

        \alert{\underline{Compute}} the following substitutions

         \begin{align*}
                & \ast[t/y][s/z] &  = \dots 
                \\
                & \pv{y,z}[t/y][s/z] & = \dots 
                \\
                & (\lambda x. \, x) [t/x]  & = \dots
                \\
                & (\lambda x. \, \pv{x,y})[z/y] & = \dots
                \\
                &  (\lambda x. \, \pv{x,y})[x/y] & = \dots
        \end{align*}
\end{frame}

\begin{slide}{Via the Programming Lens}
  \begin{flalign*}
      \infer[\text{(exch)}]{\Gamma, y: \typeB, x: \typeA,\Delta \vljud t: \typeC}{
      \Gamma, x : \typeA, y : \typeB,\Delta \vljud t: \typeC}
      \hspace{2cm}
      \infer[\text{(weak)}]{\Gamma, x : \typeB \vljud t : \typeA}{\Gamma \vljud t : \typeA}
  \end{flalign*}
  \begin{flalign*}
      \infer[\text{(cut elimination)}]{\Gamma\vljud \dots :\typeB}{
      \Gamma, x: \typeA \vljud t: \typeB \qquad \Gamma \vljud s : \typeA}
  \end{flalign*}
\end{slide}

\begin{slide}{Via the Programming Lens}
  \begin{flalign*}
      \infer[\text{(exch)}]{\Gamma, y: \typeB, x: \typeA,\Delta \vljud t: \typeC}{
      \Gamma, x : \typeA, y : \typeB,\Delta \vljud t: \typeC}
      \hspace{2cm}
      \infer[\text{(weak)}]{\Gamma, x : \typeB \vljud t : \typeA}{\Gamma \vljud t : \typeA}
  \end{flalign*}
  \begin{flalign*}
          \infer[\text{(cut elimination)}]{\Gamma\vljud t[s/x] :\typeB}{
      \Gamma, x: \typeA \vljud t: \typeB \qquad \Gamma \vljud s : \typeA}
  \end{flalign*}

  \pause
  \bigskip
  \begin{center}
          Substitution also fundamental in the study of
          \alert{\underline{equivalence}} 
  \end{center}
\end{slide}

\begin{frame}{An Equational System pt. I}
        \begin{align*}
                \pi_1 \pv{t,s} =_{\beta \eta} t
                \hspace{1cm}
                &
                t =_{\beta \eta} \ast \hspace{2cm} (\text{if } t : 1) 
                \hspace{1cm}
                \\
                \pi_2 \pv{t,s} =_{\beta \eta} s 
                \hspace{1cm}
                &
                \lambda x. \, t \> s =_{\beta \eta} t[s/x] 
                \\
                \pv{ \pi_1 \, t, \pi_2 \, t } =_{\beta \eta} t
                \hspace{1cm}
                &
                \lambda x. \, (t \, x) =_{\beta \eta} t
        \end{align*}
\end{frame}

\begin{frame}{An Equational System pt. II}
        \begin{align*}
                t =_{\beta \eta} t
                \hspace{2cm}
                \infer{s =_{\beta \eta} t}{t =_{\beta \eta} s}
                \hspace{2cm}
                \infer{t =_{\beta \eta} u}
                {
                        t =_{\beta \eta} s \qquad
                        s =_{\beta \eta} u
                }
        \end{align*}
        %
        \begin{flalign*}
          \infer{\pi_1 \, t =_{\beta \eta} \pi_1 \, s}{
          t =_{\beta \eta} s} 
        \hspace{1.5cm}
          \infer{\pi_2 \, t =_{\beta \eta} \pi_2\, s}{
          t =_{\beta \eta} s} 
        \hspace{1.5cm}
        \infer{ \pv{t,u} =_{\beta \eta} \pv{s, v} }{
                          t =_{\beta \eta} s
                          \qquad
                          u =_{\beta \eta} v
                  }
        \end{flalign*}
        %
        \begin{flalign*}
                \infer{ t \> u =_{\beta \eta} s \> v }{
                          t =_{\beta \eta} s
                          \qquad
                          u =_{\beta \eta} v
                  }
                \hspace{2cm}
                \infer {\lambda x. \> t =_{\beta \eta} \lambda x. \> s}{
                        t =_{\beta \eta} s
                }
        \end{flalign*}
        \begin{align*}
                \infer{
                        \pi \Gamma \vljud t =_{\beta \eta}  s
                }{
                        \Gamma \vljud t =_{\beta \eta} s
                }
                \hspace{2cm}
                \infer{
                        u[t/x] =_{\beta \eta} v[s/x]
                }{
                        u =_{\beta \eta} v \qquad t =_{\beta \eta} s
                }
        \end{align*}
\end{frame}

\begin{slide}{Equivalence Re-Revisited}
  Show that the following equations hold
  \begin{flalign*}
    \pi_1 \pv{x,y}\ & =_{\beta \eta}
    x  \\[5pt]
    t\ & =_{\beta \eta} \
    \langle \pi_1\ t, \pi_2\ t \rangle
    \\[5pt]
    (\lambda y. \, \pv{x,y})\>  \> x  \,
       & =_{\beta \eta} \
       \pv{x,x}
  \end{flalign*}
  \begin{flalign*}
    \lambda x. \, \pv{\pi_2 \, x, \pi_1 \, x}\>
    \Big (\lambda y. \, \pv{\pi_2 \, y, \pi_1 \, y} \> z \Big ) 
       & =_{\beta \eta} z
  \end{flalign*}

\end{slide}

\section{Disjunctive Types}

\begin{frame}{Learning Programming from Logic}

       If conjunction in logic corresponds to pairing in programming \dots what
       does \alert{\underline{disjunction}} in logic correspond to ?

\end{frame}

\begin{slide}{Revisiting our Deductive System}
  \begin{minipage}[0.3\textheight]{\textwidth}
  \begin{columns}[c]
  \begin{column}{0.5\textwidth}
          $\typeA,\typeB \dots$ denote \alert{\underline{propositions}}
          and $\typeOne$ a proposition that always holds   
  \end{column}
  \begin{column}{0.45\textwidth}
        \includegraphics[scale=0.2]{images/gentzen.jpg}
        \includegraphics[scale=0.16]{images/prawitz.jpg}
  \end{column}
  \end{columns}
  \end{minipage}

  If $\typeA$ and $\typeB$ are propositions then
  \begin{itemize}
    \item $\typeA \times \typeB$ is a proposition -- 
        conjunction of $\typeA$ and $\typeB$
    \item $\typeA \to \typeB$ is a proposition -- 
            implication of $\typeB$ from $\typeA$
    \item $\typeA + \typeB$ is a proposition --
            \alert{\underline{disjunction}} of $\typeA$ and $\typeB$
  \end{itemize}
  
\end{slide}

\begin{frame}{Revisiting our Deductive System}
  
 \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud \typeA}{\typeA \in \Gamma} \hspace{0.8cm}
      \infer[(\rulename{trv})]{\Gamma \vljud  1}{}  \hspace{0.8cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \typeA}{\Gamma \vljud \typeA \times \typeB} \hspace{0.8cm}
      \infer[(\rulename{\pi_2})]{\Gamma \vljud \typeB}{\Gamma \vljud \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
      \infer[(\rulename{prd})]{\Gamma \vljud \typeA \times \typeB}
      {\Gamma \vljud \typeA \qquad \Gamma \vljud \typeB} \hspace{0.4cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \typeA \to \typeB}{\Gamma, \typeA \vljud  \typeB}
      \hspace{0.4cm}
      \infer[(\rulename{app})]{\Gamma \vljud \typeB}
      {\Gamma \vljud  \typeA \to \typeB \quad
        \Gamma \vljud  \typeA}
  \end{flalign*}

  \vspace{-0.4cm}

  \noindent\dotfill{}

  \vspace{-0.4cm}

  \begin{flalign*}
          \infer[(\rulename{inl})]{
                \Gamma \vljud \typeA + \typeB
          }{
                \Gamma \vljud \typeA
          }
          \hspace{2cm}
          \infer[(\rulename{inr})]{
                \Gamma \vljud \typeA + \typeB
          }{
                \Gamma \vljud \typeB
          }
  \end{flalign*}
  \begin{flalign*}
          \infer[(\rulename{coprd})]{
               \Gamma \vljud \typeC
          }{
            \Gamma \vljud \typeA + \typeB
            \qquad
            \Gamma,  \typeA \vljud \typeC
            \qquad
            \Gamma,  \typeB \vljud \typeC
          }
  \end{flalign*}
  } 
\end{frame}

\begin{frame}{Conditionals Enter the Scene !}

  \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\Gamma \vljud x : \typeA}{x :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[(\rulename{triv})]{\Gamma \vljud \ast : 1}{}  \hspace{1.2cm}
      \infer[(\rulename{\pi_1})]{\Gamma \vljud \pi_1 \, t : \typeA }
      {\Gamma \vljud t: \typeA \times \typeB}
  \end{flalign*}
  \begin{flalign*}
     \infer[(\rulename{prd})]{\Gamma \vljud \langle t,s \rangle :
        \typeA \times \typeB}
      {\Gamma \vljud t: \typeA \qquad \Gamma \vljud s: \typeB} \hspace{1cm}
      \infer[(\rulename{cry})]{\Gamma \vljud \lambda x : \typeA . \, t : \typeA
        \to \typeB}
      {\Gamma, x : \typeA \vljud t : \typeB}
    \end{flalign*}
   \begin{flalign*}
      \infer[(\rulename{app})]{\Gamma \vljud t \, s : \typeB}
      {\Gamma \vljud  t : \typeA \to \typeB \quad
        \Gamma \vljud  s : \typeA}
    \end{flalign*}

  \vspace{-0.4cm}

  \noindent\dotfill{}

  \vspace{-0.4cm}
  \begin{flalign*}
          \infer[(\rulename{inl})]{
                  \Gamma \vljud \inl_{\typeB} \> t : \typeA + \typeB
          }{
                \Gamma \vljud t: \typeA
          }
          \hspace{1.5cm}
          \infer[(\rulename{inr})]{
                  \Gamma \vljud \inr_{\typeA} \> t : \typeA + \typeB
          }{
                \Gamma \vljud t : \typeB
          }
  \end{flalign*}
  \begin{flalign*}
          \infer[(\rulename{coprd})]{
          \Gamma \vljud \mathrm{case} \> t \> \mathrm{ of }
          \> \inl(x) \Rightarrow s ; \inr(y) \Rightarrow u : \typeC
          }{
            \Gamma \vljud t: \typeA + \typeB
            \qquad
            \Gamma, \, x : \typeA \vljud s: \typeC
            \qquad
            \Gamma, \, y : \typeB \vljud u : \typeC
          }
  \end{flalign*}
  } 
\end{frame}

\begin{frame}{Exercises}
  Derive the following judgements
  \begin{itemize}
          \item $\typeA + \typeB \vljud \typeB + \typeA$ 
          \item $\typeA \times (\typeB + \typeC) \vljud
                \typeA \times \typeB + \typeA \times \typeC$
          \item $\typeA \times \typeB + \typeA \times \typeC \vljud \typeA$
          \item $\typeA \times \typeB + \typeA \times \typeC \vljud \typeB + \typeC$
          \item $\typeA \times \typeB + \typeA \times \typeC \vljud
                  \typeA \times (\typeB + \typeC)$
  \end{itemize}        

  Then build the corresponding programs
\end{frame}
\begin{slide}{Revisiting our Denotational Semantics}
  Types $\typeA$ interpreted as \alert{\underline{sets}} $\sem{\typeA}$
  \begin{flalign*}
    \sem{1} & = \{ \star \} \\
    \sem{\typeA \times \typeB} & = \sem{\typeA} \times \sem{\typeB} \\
    \sem{\typeA \to \typeB} & = \sem{\typeB}^{\sem{\typeA}} 
  \end{flalign*}

  \vspace{-0.8cm}

  \noindent\dotfill{}

  \vspace{-1.2cm}

  \begin{flalign*}
   \sem{\typeA + \typeB} & = \sem{\typeA} + \sem{\typeB}
 \end{flalign*}

 Judgements $\Gamma \vljud t : \typeA$ interpreted as \alert{\underline{functions}}
 \begin{flalign*}
   \sem{\Gamma \vljud t : \typeA}\ : \sem{\Gamma}\ \longrightarrow \sem{\typeA}
 \end{flalign*}

\end{slide}
\begin{slide}{Functions: Basic Facts}

  There exist injection functions
  \begin{flalign*}
    i_1 : X \to X + Y \hspace{1cm} x \mapsto i_1(x) \\
    i_2 : Y \to X + Y  \hspace{1cm} y \mapsto i_2(y)
  \end{flalign*}

  We can always `co-pair' two functions into
  $f : A \to X$, $g : B \to X$
  \begin{flalign*}
          [f,g] : A + B \to X \hspace{1cm} 
          [f,g](i_1(x)) = f (x), \quad
          [f,g](i_2(y)) = g (y)
  \end{flalign*}

\end{slide}



\begin{slide}{Revisiting our Denotational Semantics}
\small{
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud x_i : \typeA} = \pi_i}{x_i :
        \typeA \in \Gamma} \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \ast : 1}\ =\ !}{}  \hspace{1.2cm}
      \infer[]{\sem{\Gamma \vljud \pi_1 t : \typeA} = \pi_1 \comp f }
      {\sem{\Gamma \vljud t : \typeA \times \typeB} = f}
  \end{flalign*}
  \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud \langle t,s \rangle :
        \typeA \times \typeB}\ = \pv{f,g}}
    {\sem{\Gamma \vljud t: \typeA}\ = f \qquad \sem{\Gamma \vljud s: \typeB}\ = g}
    \hspace{0.3cm}
     \infer[]{\sem{\Gamma \vljud \lambda x : \typeA . \, t : \typeA
        \to \typeB}\ = \lambda f}
      {\sem{\Gamma, x : \typeA \vljud t : \typeB}\ = f}
    \end{flalign*}
   \begin{flalign*}
      \infer[]{\sem{\Gamma \vljud t \, s : \typeB}\ = \mathrm{app} \comp \pv{f,g}}
      {\sem{\Gamma \vljud  t : \typeA \to \typeB}\ = f \quad
        \sem{\Gamma \vljud  s : \typeA}\ = g}
    \end{flalign*}

  \vspace{-0.4cm}

  \noindent\dotfill{}

  \vspace{-0.5cm}

    \begin{flalign*}
          \infer[]{
                  \sem{\Gamma \vljud \inl_{\typeB} \> t : \typeA + \typeB}\ =
                  i_1 \comp f
          }{
                  \sem{\Gamma \vljud t: \typeA}\ = f 
          }
          \hspace{1.5cm}
          \infer[]{
                  \sem{\Gamma \vljud \inr_{\typeA} \> t : \typeA + \typeB}\ =
                  i_2 \comp f
          }{
                  \sem{\Gamma \vljud t : \typeB}\ = f
          }
  \end{flalign*}
  \begin{flalign*}
          \infer[]{
          \sem{\Gamma \vljud \mathrm{case} \> t \> \mathrm{ of }
          \> \inl(x) \Rightarrow s ; \inr(y) \Rightarrow u : \typeC}\
          = [g,h] \comp \mathrm{dist} \comp \pv{\id,f}
          }{
            \sem{\Gamma \vljud t: \typeA + \typeB}\ = f
            \qquad
            \sem{\Gamma, \, x : \typeA \vljud s: \typeC}\ = g
            \qquad
            \sem{\Gamma, \, y : \typeB \vljud u : \typeC}\ = h
          }
  \end{flalign*}

}
\end{slide}

\begin{frame}{Exercises}

        {\small
        \begin{flalign*}
               \sem{ x \vljud
                       \mathrm{case} \> x \>
                       \mathrm{of} \> \inl(y) \Rightarrow \inr(y) ;
               \inr(z) \Rightarrow \inl(z) }\ 
               & =\ \dots
               \\
               \sem{ x \vljud
                       \mathrm{case} \> x \>
                       \mathrm{of} \> \inl(y) \Rightarrow \pi_1 \, y ;
               \inr(z) \Rightarrow \pi_1 \, z }\ 
               & =\ \dots
               \\
               \sem{ x \vljud
                       \mathrm{case} \> x \>
                       \mathrm{of} \> \inl(y) 
                       \Rightarrow \pv{ \pi_1 \, y , \inl \, \pi_2 \, y} ;
               \inr(z) \Rightarrow \pv{ \pi_1 \, z , \inl \, \pi_2 \, z}}\
               & =\ \dots
        \end{flalign*}
        }
\end{frame}
\begin{frame}{Revisiting our Equational System}
        \begin{align*}
                \pi_1 \pv{t,s} =_{\beta \eta} t
                \hspace{1cm}
                &
                t =_{\beta \eta} \ast \hspace{2cm} (\text{if } t : 1) 
                \hspace{1cm}
                \\
                \pi_2 \pv{t,s} =_{\beta \eta} s 
                \hspace{1cm}
                &
                \lambda x. \, t \> s =_{\beta \eta} t[s/x] 
                \\
                \pv{ \pi_1 \, t, \pi_2 \, t } =_{\beta \eta} t
                \hspace{1cm}
                &
                \lambda x. \, (t \, x) =_{\beta \eta} t
        \end{align*}

        \vspace{-0.4cm}

        \noindent\dotfill{}

        \vspace{-0.8cm}

        \begin{flalign*}
                \mathrm{case} \> \inl \> t \> \mathrm{of} \>
                \inl(x) \Rightarrow s;  \inr(y) \Rightarrow u
                & =_{\beta \eta} s[t/x]
                \\
                \mathrm{case} \> \inr \> t \> \mathrm{of} \>
                \inl(x) \Rightarrow s;  \inr(y) \Rightarrow u
                & =_{\beta \eta} u[t/y]
        \end{flalign*}
        \vspace{-1.2cm}
        \begin{flalign*}
                \mathrm{case} \> x \> \mathrm{of} \>
                \inl(y) \Rightarrow t[\inl(y)/x]; 
                \inr(z) \Rightarrow t[\inr(z)/x]
                & =_{\beta \eta} t
        \end{flalign*}

\end{frame}

\begin{frame}{Exercises}

        Show that
        \begin{flalign*}
                \Big (\lambda x. \, \mathrm{case} \> x \> \mathrm{of} \>
                \inl(y) \Rightarrow \inr (y) ;
                \,
                \inr(z) \Rightarrow \inl (z) \Big ) \> \inl(a)
                =_{\beta \eta} \inr (a)
                \\
                \Big (\lambda x. \, \mathrm{case} \> x \> \mathrm{of} \>
                \inl(y) \Rightarrow \inr (y) ;
                \,
                \inr(z) \Rightarrow \inl (z) \Big ) \> \inr(a)
                =_{\beta \eta} \inl (a)
        \end{flalign*}

        Prove the following implication
        \begin{flalign*}
                \begin{cases}
                        (\lambda x. \, t) \> \inl (y) =_{\beta \eta} 
                        (\lambda x. \, s) \> \inl (y)
                        \\
                        (\lambda x. \, t) \> \inr (z) =_{\beta \eta}
                        (\lambda x. \, s) \> \inr (z)
                \end{cases}
                \Longrightarrow
                \lambda x. \, t =_{\beta \eta} \lambda x. \, s
        \end{flalign*}
\end{frame}

\begin{frame}[plain]

        \begin{center}
                What can logic teach us more about programming ?
        \end{center}

\end{frame}

\section{Beyond Cartesianism}

\begin{frame}{Eager vs. Lazy}

        \begin{block}{Lazy Evaluation (\emph{e.g.} Haskell)}
                $\pi_2 \, \pv{\text{divergence}, 0} = 0$
        \end{block}
        
        \bigskip
        \begin{block}{Strict Evaluation (\emph{e.g.} Python)}
                $\pi_2 \, \pv{\text{divergence}, 0} = \text{divergence}$
        \end{block}
        
        \bigskip
        \pause
        Strict evaluation \alert{\underline{breaks product laws}}
\end{frame}

\begin{frame}{Quantum Computation: No-cloning and Entanglement}

        Forbidden to write down $\pv{x,x}$

        \bigskip
        \pause
        Certainly false that $\pv{\pi_1 \, x, \pi_2 \, x} = x$


        \bigskip
        \pause
        Last case also holds in \alert{\underline{probabilistic}} programming
\end{frame}

\begin{frame}{Beyond Cartesianism}

        \caixa{
                \begin{center}
                        Cartesian structures thus often non-adequate 
                \end{center}
        }

        \bigskip
        We will explore a \alert{\underline{more general}} approach
\end{frame}

\begin{frame}{Linear $\lambda$-calculus}

        Controlled use of \alert{\underline{resources}}
        (no duplication, no discarding)

        \bigskip
        Product laws need not hold

        \bigskip
        Broader range of applications than `Cartesian $\lambda$-calculus'
\end{frame}

\begin{slide}{A Linear Deductive System}
  \begin{minipage}[1\textheight]{\textwidth}
  \begin{columns}[c]
  \begin{column}{0.75\textwidth}
          $\typeA,\typeB \dots$ denote propositions
          and $\typeI$ a trivial one 
  \end{column}
  \begin{column}{0.18\textwidth}
        \includegraphics[scale=0.3]{images/girard.jpg}
  \end{column}
  \end{columns}
  \end{minipage}

  \vspace{-0.5cm}
  If $\typeA$ and $\typeB$ are propositions then
  \begin{itemize}
    \item $\typeA \otimes \typeB$ is a proposition -- 
        `linear conjunction' of $\typeA$ and $\typeB$
    \item $\typeA \multimap \typeB$ is a proposition -- 
            `linear implication' of $\typeB$ from $\typeA$
  \end{itemize}
  
\end{slide}

\begin{frame}{A Linear Deductive System}
  
  $\Gamma,\Delta \dots$ denote lists of propositions

  \small{
  \begin{flalign*}
      \infer[(\rulename{ass})]{\typeA \vljud \typeA}{} \hspace{2cm}
      \infer[(\rulename{trv})]{(-) \vljud  \typeI}{}  \hspace{2cm}
      \infer[(\rulename{dsc})]{\Gamma,\Delta \vljud \typeA}{
              \Gamma \vljud \typeI \qquad
              \Delta \vljud \typeA
      }
  \end{flalign*}
  \begin{flalign*}
      \infer[(\rulename{prd})]{\Gamma,\Delta \vljud \typeA \otimes \typeB}
      {\Gamma \vljud \typeA \qquad \Delta \vljud \typeB} \hspace{2cm}
      \infer[(\rulename{prj})]{
              \Gamma, \Delta \vljud \typeC
      }{
              \Gamma \vljud \typeA \otimes \typeB
              \qquad
              \Delta, \typeA, \typeB \vljud \typeC
      }
  \end{flalign*}
  \begin{flalign*}
      \infer[(\rulename{cry})]{\Gamma \vljud \typeA \multimap \typeB}
      {
        \Gamma, \typeA \vljud  \typeB
      }
      \hspace{2cm}
      \infer[(\rulename{app})]{\Gamma,\Delta \vljud \typeB}
      {\Gamma \vljud  \typeA \multimap \typeB \quad
        \Delta \vljud  \typeA}
  \end{flalign*}
        } 
  

\end{frame}

\begin{frame}{Linear $\lambda$-calculus}
  
  \small{
  \begin{flalign*}
          \hspace{-0.2cm}
      \infer[]{x : \typeA \vljud x : \typeA}{} \hspace{2cm}
      \infer[]{(-) \vljud  \ast : \typeI}{}  \hspace{2cm}
      \infer{\Gamma,\Delta \vljud t \text{ to } \ast.\  \, s: \typeA}{
              \Gamma \vljud t : \typeI \qquad
              \Delta \vljud s : \typeA
      }
  \end{flalign*}
  \begin{flalign*}
  \hspace{-0.2cm}
      \infer[]{\Gamma,\Delta \vljud t \otimes s : \typeA \otimes \typeB}
      {\Gamma \vljud t : \typeA \qquad \Delta \vljud s: \typeB} \hspace{2cm}
      \infer{
              \Gamma, \Delta \vljud 
              \text{pm } t \text{ to } x \otimes y.\, s: \typeC
      }{
              \Gamma \vljud t : \typeA \otimes \typeB
              \qquad
              \Delta, x: \typeA, y: \typeB \vljud s: \typeC
      }
  \end{flalign*}
  \begin{flalign*}
      \hspace{-0.2cm}
      \infer[]{\Gamma \vljud \lambda x : \typeA.\ t : \typeA \multimap \typeB}
      {
        \Gamma, x: \typeA \vljud t : \typeB
      }
      \hspace{2cm}
      \infer[]{\Gamma,\Delta \vljud t \, s : \typeB}
      {\Gamma \vljud t: \typeA \multimap \typeB \quad
        \Delta \vljud s:  \typeA}
  \end{flalign*}
        } 
  

\end{frame}

\begin{slide}{Examples of Linear $\lambda$-terms}
  \begin{flalign*}
          & x : \typeA \vljud x : \typeA && \text{(identity)}
          \\[15pt]
          & x : \typeA \otimes \typeB \vljud 
          \text{pm}\ x \text{ to } a \otimes b. \, b \otimes a : \typeB \otimes \typeA
          && \text{(swap)} 
          \\[15pt]
          & (-) \vljud \lambda x. \,
          \text{pm}\ x \text{ to } a \otimes b. \, b \otimes a :
          \typeA \otimes \typeB \multimap \typeB \otimes \typeA
          && \text{(swap curried)}
          \\[15pt]
          &
          x : \typeI \otimes \typeA \vljud \text{pm } x \text{ to }
          i \otimes a. \, (i \text{ to } \ast.\, a) : \typeA
          && \text{(discard triv)}
  \end{flalign*}
\end{slide}

\begin{frame}{Examples of Linear $\lambda$-terms in Quantum}
  \small{
  \begin{flalign*}
          & x : \typeB, y : \typeB \vljud \mathrm{cnot}(\mathrm{had}(x),y) 
          : \typeQ \otimes \typeQ && \text{(EPR pair)}
          \\[15pt]
          &
          x : \typeB, y : \typeB \vljud \Big (\lambda x. \,
          \text{pm}\ x \text{ to } a \otimes b. \, b \otimes a \Big )
          \Big (\mathrm{cnot}(\mathrm{had}(x),y) \Big )
                    && \text{(EPR swapped)} 
          \end{flalign*}
  }
          \medskip
          \pause
          \caixa{
          \begin{center}
                 Does swapping actually have any effect on the pair ?
          \end{center}
          }
\end{frame}
\begin{frame}{Next Steps}

      Answer to previous question calls for semantics

      \pause
      \medskip
      More generally a full study of linear $\lambda$-calculus
      calls for semantics

      \pause
      \medskip
      \dots\ which we will obtain via \alert{\underline{Category Theory}} :-)
      \end{frame}

\end{document}
