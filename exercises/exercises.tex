\documentclass[a4paper, 11pt]{article}

%% packages
\usepackage{fullpage} % changes the margin
\usepackage{hyperref} % Links
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{braket}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{quantikz}
\usepackage[linewidth=1pt]{mdframed}
%%

%% environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{examples}{Example}
\newtheorem{exercises}{Exercises}
\newtheorem{exercise}{Exercise}
\newtheorem{postulate}{Postulate}
\newtheorem{problem}{Problem}
%%

%% config
\date{}
\linespread{1.15}
\newcommand{\blue}[1]{\textcolor{blue}{#1}}
\input{macros}
%%

\begin{document}

\allowdisplaybreaks[2]
\title{\large{Semantics of Programming Languages 2024/25}
        \\ \large{University of Minho} 
}

\author{\small{Renato Neves} \small
(\href{mailto:nevrenato@di.uminho.pt}{nevrenato@di.uminho.pt})}
\maketitle

\section{Summary}

This document presents a list of exercises to help you prepare for the test.
It addresses the three styles of semantics that we have studied so far: namely
operational, denotational, and axiomatic semantics.

\section{Operational Semantics}

\subsection{Small-step}
        We started our lectures with the following very simple propositional
        language.
        \[
                \prog{b} ::= \prog{x} \mid \prog{b} \wedge \prog{b} \mid \neg \prog{b}
        \]
        Recall that $\prog{x}$ denotes a variable (from a given stock of
        variables).  Next we established the (small-step) operational semantics
        detailed in Figure~\ref{fig:small1}.
        %
        \begin{figure}[h]
        \begin{minipage}{1\textwidth}
        \begin{flalign*}
                \infer[(\text{var})]{\langle \mathtt{x}, \sigma \rangle 
                \longrightarrow \sigma(\mathtt{x})}{} \qquad \qquad
                %
                \hspace{2cm}
                %
                \infer[(\text{neg$_1$})]{\langle \neg \prog{b}, \sigma \rangle 
                \longrightarrow \neg v}{
                   \pv{\prog{b}}{\sigma} \longrightarrow
                   v
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{neg$_2$})]{
                \pv{\neg \prog{b}}{\sigma} 
                \longrightarrow \pv{\neg \prog{b'}}{\sigma'}
                }{
                \pv{\prog{b}}{\sigma} 
                \longrightarrow \pv{\prog{b'}}{\sigma'}
                } 
                %
                \hspace{2cm}
                %
                \infer[(\text{and$_1$})]{
                        \pv{\prog{b_1} \wedge \prog{b_2} }{\sigma}
                \longrightarrow \prog{ff}}{
                   \pv{\prog{b_1}}{\sigma} \longrightarrow
                   \prog{ff}
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                %
                \infer[(\text{and$_2$})]{
                %
                \pv{ \prog{b_1} \wedge \prog{b_2} }{ \sigma }
                \longrightarrow 
                \pv{ \prog{b_2} }{\sigma}  }
                {
                   \pv{\prog{b_1}}{\sigma} \longrightarrow
                   \prog{tt}
                }
                %
                \hspace{2cm}
                %
                \infer[(\text{and$_3$})]{
                        \pv{\prog{b_1} \wedge \prog{b_2} }{\sigma}
                \longrightarrow \pv{\prog{b_1'} \wedge \prog{b_2}}{\sigma'} }{
                   \pv{\prog{b_1}}{\sigma} \longrightarrow
                   \pv{\prog{b_1'}}{\sigma'}
                }
        \end{flalign*}
        \end{minipage}
        \label{small_prop}
        \caption{Small-step operational semantics for the propositional language}
        \label{fig:small1}
        \end{figure}

        \begin{problem}
                It makes sense to add an implication construct $\prog{b}
                \Rightarrow \prog{b}$ to the simple language. Which semantic
                rules would you add to Figure~\ref{fig:small1} in order to
                cover this new construct?
        \end{problem}

        In the lectures we have also defined the `complexity function'         
        \begin{align*}
                \mathrm{compl}(\prog{x}) & = 1  \\
                \mathrm{compl}(\prog{\neg b}) & = \mathrm{compl}(\prog{b}) \\
                \mathrm{compl}(\prog{b}_1 \wedge \prog{b}_2) & =
                \mathrm{compl}(\prog{b}_1) + \mathrm{compl}(\prog{b}_2)
        \end{align*}
        In a nutshell, it provides an upper bound to the number of steps a
        proposition needs to be fully evaluated.

        \begin{problem}
                Show by induction (on the syntactic structure of propositions)
                that $\mathrm{compl}(\prog{b}) \geq 1$ for every $\prog{b}$.
                Next, show by induction (over the depth of derivation trees)
                that the implication below holds for all propositions
                $\prog{b}$ and $\prog{b'}$.
                \[
                        \text{ If }\pv{\prog{b}}{\sigma} \longrightarrow
                        \pv{\prog{b'}}{\sigma}
                        \text{ then } \mathrm{compl}(\prog{b}) > \mathrm{compl}(\prog{b'})
                \]
        \end{problem}

        Let us consider now the grammars of arithmetic expressions and while-programs 
        that were studied throughout the lectures. They were defined as follows.
        \[
                \prog{e} ::=  \mathtt{n}  \mid \mathtt{e \cdot e}
                \mid  \mathtt{x}  \mid \mathtt{e + e}
        \]
        \[
                \prog{p} ::= \mathtt{x} := \mathtt{e} \mid
        	\mathtt{p \> \blue{;} \> p} \mid
        	\mathtt{\blue{if} \> b \> \blue{then} \> p \> \blue{else} \> p} \mid
        	\mathtt{\blue{while} \> b \> \blue{do} \> \{ \> p \> \}}
        \]
        \begin{problem}
                Remarkably in the lectures we did not see a small-step
                operational semantics for the arithmetic expressions. Can you
                define one such semantics now?
        \end{problem}

        What we did see however was a small-step operational semantics for the while-language,
        which is now detailed in Figure~\ref{fig:small2}.
        \begin{figure}[h]
        \begin{minipage}{1\textwidth}
        \begin{flalign*}
                \infer[(\text{asg})]{
                        \langle \mathtt{x := e}, \sigma \rangle \longrightarrow
                        \sigma[v / \mathtt{x}]
                }{
                       \langle \mathtt{e}, \sigma \rangle \longrightarrow^\star v
                } \hspace{2cm}
                \infer[(\text{seq$_1$})]{
                        \langle \mathtt{p \> \blue{;} \> q}, \sigma \rangle \longrightarrow 
                        \pv{\prog{q}}{\sigma'}
                }{
                        \langle \mathtt{p}, \sigma \rangle \longrightarrow \sigma'
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{seq$_2$})]{
                        \langle \mathtt{p \> \blue{;} \> q}, \sigma \rangle \longrightarrow 
                        \pv{\prog{p' \> \blue{;} \> q}}{\sigma'}
                }{
                        \langle \mathtt{p}, \sigma \rangle 
                        \longrightarrow \pv{\prog{p'}}{\sigma'}
                }
                \hspace{2cm}
                \infer[(\text{if$_1$})]{
                        \langle \mathtt{\blue{if} \> b \> \blue{then} \> \> 
                        p \> \blue{else} \> q}, 
                        \sigma \rangle \longrightarrow \pv{\prog{p}}{\sigma}
                }{
                        \langle \mathtt{b}, \sigma \rangle \longrightarrow^\star \mathtt{tt} 
                } 
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{if$_2$})]{
                        \langle \mathtt{\blue{if} \> b \> \blue{then} \> \> 
                        p \> \blue{else} \> q}, 
                        \sigma \rangle \longrightarrow \pv{\prog{q}}{\sigma}
                }{
                        \langle \mathtt{b}, \sigma \rangle \longrightarrow^\star \mathtt{ff} 
                } 
                \hspace{2cm}
                \infer[(\text{wh$_2$})]{
                        \langle 
                        \mathtt{\blue{while} \> b \> \blue{do} \> \{ \> p \> \}}, \sigma \rangle
                        \longrightarrow^\star \sigma
                }{
                        \langle \mathtt{b}, \sigma \rangle \longrightarrow^\star \mathtt{ff}
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{wh$_1$})]{
                        \langle \mathtt{\blue{while} \> b \> \blue{do} \> \{ \> p \> \}}, 
                        \sigma \rangle
                        \longrightarrow 
                        \pv{\prog{p} \> \blue{;} \> 
                        \mathtt{\blue{while} \> b \> \blue{do} \> \{ \> p \> \}}}{
                        \sigma}
                }{
                        \pv{\prog{b}}{\sigma} \longrightarrow^\star \prog{tt} 
                }
        \end{flalign*}
        \end{minipage}
        \caption{Small-step operational semantics for the while-language}
        \label{fig:small2}
        \end{figure}

        \begin{problem}
                Thus explain the meaning of the notation $\longrightarrow^\star$.
        \end{problem}

        \begin{problem}
                Calculate via the semantics in Figure~\ref{fig:small2} the
                chains of transitions that arise from the two programs below.
                \[
                        \prog{ x := 1} \> \blue{;} \> \prog{x := 2}
                        %
                        \hspace{3cm}
                        %
                        \prog{ \blue{if} } 
                        \> \> \prog{tt} \> \> \prog{ \blue{then}} \> \>
                        \prog{ x := 1} \> \blue{;} \> \prog{x := 2}
                        \> \> \prog{ \blue{else}}
                        \> \> \prog{ x := 3 }
                \]
                Finally give an example of a program that generates an
                \emph{infinite} sequence of transitions. Justify your choice
                mathematically :-).
        \end{problem}

\subsection{Big-step}

We now lean over our big-step operational semantics. Recall that it abstracts
away from all intermediate computational steps performed in the context of the
small-step semantics. It is therefore better suited  for calculating outputs
and for studying program equivalence (among other things).  The big-step
semantics of our while-language is defined in
Figure~\ref{fig:big}.

\begin{problem}
        Again in the lectures we did not see a big-step operational
        semantics for the arithmetic expressions. Can you define one such
        semantics now?
\end{problem}


        \begin{figure}[h]
        \begin{minipage}{1\textwidth}
        \begin{flalign*}
                \infer[(\text{asg})]{
                        \langle \mathtt{x := e}, \sigma \rangle \Downarrow 
                        \sigma[\mathtt{v} / \mathtt{x}]
                }{
                       \langle \mathtt{e}, \sigma \rangle \Downarrow \mathtt{v}
                } 
                \hspace{2cm}
                \infer[(\text{seq})]{
                        \langle \mathtt{p \> \blue{ ;} \> q}, \sigma \rangle \Downarrow \sigma''
                }{
                        \langle \mathtt{p}, \sigma \rangle \Downarrow \sigma' \qquad
                        \langle \mathtt{q}, \sigma' \rangle \Downarrow \sigma'' 
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{if$_1$})]{
                        \langle \mathtt{\blue{ if} \> b \> \blue{ then} \> \> p \> \blue{ else} \> q}, 
                        \sigma \rangle \Downarrow \sigma'
                }{
                        \langle \mathtt{b}, \sigma \rangle \Downarrow \mathtt{tt} \qquad
                        \langle \mathtt{p}, \sigma \rangle \Downarrow \sigma'
                } 
                %
                \hspace{2cm} 
                %
                \infer[(\text{if$_2$})]{
                        \langle \mathtt{\blue{ if} \> b \> \blue{ then} \> \> p \> \blue{ else} \> q}, 
                        \sigma \rangle \Downarrow \sigma'
                }{
                        \langle \mathtt{b}, \sigma \rangle \Downarrow \mathtt{ff} \qquad
                        \langle \mathtt{q}, \sigma \rangle \Downarrow \sigma'
                } 
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{wh$_1$})]{
                        \langle \mathtt{\blue{ while} \> b \> \blue{ do} \> \{ \> p \> \}}, \sigma \rangle
                        \Downarrow \sigma''
                }{
                        \langle \mathtt{b}, \sigma \rangle \Downarrow \mathtt{tt} \qquad
                        \langle \mathtt{p}, \sigma \rangle \Downarrow \sigma' \qquad
                        \langle \mathtt{\blue{ while} \> b \> \blue{ do} \> \{ \> p \> \}}, \sigma'
                        \rangle \Downarrow \sigma'' 
                }
        \end{flalign*}
        %%
        \\[-30pt]
        %%
        \begin{flalign*}
                \infer[(\text{wh$_2$})]{
                        \langle \mathtt{\blue{ while} \> b \> \blue{ do} \> \{ \> p \> \}}, \sigma \rangle
                        \Downarrow \sigma
                }{
                        \langle \mathtt{b}, \sigma \rangle \Downarrow \mathtt{ff}
                }
        \end{flalign*}
        \end{minipage}
        \caption{A big-step operational semantics for the while-language}
        \label{fig:big}
        \end{figure}

\begin{problem}
Calculate via the semantics in Figure~\ref{fig:big} the outputs of the two
programs below.
                \[
                        \prog{ x := 1} \> \blue{;} \> \prog{x := 2}
                        %
                        \hspace{3cm}
                        %
                        \prog{ \blue{if} } 
                        \> \> \prog{tt} \> \> \prog{ \blue{then}} \> \>
                        \prog{ x := 1} \> \blue{;} \> \prog{x := 2}
                        \> \> \prog{ \blue{else}}
                        \> \> \prog{ x := 3 }
                \]
Reflect on the differences between calculating the outputs of these two
programs w.r.t. the small-step and big-step semantics.
\end{problem} 

Now that we have two different complementary semantics for our while-language
(small-step and big-step) it is useful to prove that they `agree' with each
other, or more formally that the equivalence below holds
       \[
                \pv{\prog{p}}{\sigma} \longrightarrow^\star \sigma'
                \text{ iff } \pv{\prog{p}}{\sigma} \Downarrow \sigma'
       \]
for every program $\prog{p}$ and states $\sigma,\sigma'$.  Here we will prove
just one side of the equivalence.
\begin{problem}
       Consider programs $\prog{p}$ and $\prog{p'}$ and states
       $\sigma,\sigma',\sigma''$. Prove by induction (over the depth of
       derivation trees) the following implication.
       \[
               \pv{\prog{p}}{\sigma} \longrightarrow \pv{\prog{p'}}{\sigma'}
               \Downarrow \sigma'' \text{ implies } \pv{\prog{p}}{\sigma} \Downarrow \sigma''
       \]
       Then use this last result to prove the implication below.
       \[
                \pv{\prog{p}}{\sigma} \longrightarrow^\star \sigma'
                \text{ implies } \pv{\prog{p}}{\sigma} \Downarrow \sigma'
       \]
       Are you able to prove the converse implication?
\end{problem}

Right, let us now recall the following (tentative) notion of program of
equivalence: two programs $\prog{p}$ and $\prog{q}$ will be equivalent (in
symbols $\prog{p} \equiv_o \prog{q}$) if the equivalence below holds.
       \[
                \pv{\prog{p}}{\sigma} \Downarrow \sigma'
                \text{ iff } \pv{\prog{q}}{\sigma} \Downarrow \sigma'
                \hspace{1cm} (\text{for all states } \sigma,\sigma')
       \]
\begin{problem}
        Prove the two equivalences propounded below.
        \begin{itemize}
                \item $\mathtt{(p \> \blue{ ;} \> q) \> {\blue ;} \> r} \equiv_o
                        \mathtt{p \> \blue{ ;} \> (q \> {\blue ;} \> r)}$
                \item $\mathtt{(\blue{ if} \> b \> \blue{ then} \> p \> \blue{ else} \> q) 
                      \> \blue{ ;} \> \prog{r}} \equiv_o 
                      \mathtt{\blue{ if} \> b \> \blue{ then} \> p \> \blue{ ;} \> r \> 
                      \blue{ else} \> q \> \blue{ ;} \> r}$ 
        \end{itemize}
\end{problem}

Recall now our second notion of program equivalence (the one that compilers
tacitly use). It is usually referred to as \emph{contextual equivalence} and
recurs to the following grammar of `contexts'.
\[              
                C ::= [-] \mid C \> \prog{ \blue{;}} \> \prog{p} 
                \mid 
                \prog{p} \> \prog{ \blue{;}} \> C 
                \mid 
                \mathtt{\blue{ if} \> b \> \blue{ then} \>} C \mathtt{\> \blue{ else} \> p} 
                \mid
                \mathtt{\blue{ if} \> b \> \blue{ then} \>} \prog{p} \mathtt{\> \blue{ else} \> C} 
                \mid
                \mathtt{\blue{ while} \> b \> \blue{ do} \> \{ \>} C \mathtt{\> \}}
\]
Two programs $\prog{p}$ and $\prog{q}$ will be contextually equivalent (in
symbols $\prog{p} \equiv \prog{q}$) if the equivalence below holds.
\[
               \pv{C[\prog{p}]}{\sigma} \Downarrow \sigma'
               \text{ iff } \pv{C[\prog{q}]}{\sigma} \Downarrow \sigma'
               \hspace{1cm} (\text{for all states } \sigma,\sigma' \text{ and contexts } C)
\]
\begin{problem}
        The natural question then arises of whether the equivalence below holds
        \[
                \prog{p} \equiv \prog{q} \text{ iff } \prog{p} \equiv_o \prog{q} 
        \]
        The left-to-right direction is clear, but what about the inverse direction?
        Can you prove it? Where do you get stuck?
\end{problem}

\section{Denotational Semantics}

Ok, we now focus on the denotational semantics of the previous lectures.
Recall that not only it helped us solve the previous problem, it also allowed
us to `import' knowledge from other mathematical theories (\eg\ `program
calculus'). 

A main challenge of this semantics was the interpretation of while-loops which
required us to touch on the surface of Domain theory and fixed-points. We start
from this end, in particular with the notion of a poset.
\begin{problem}
        Consider a set $\mathrm{State}$ of states. Show that it is a partially
        ordered set (poset) when it comes equipped with equality as the partial
        order.  Show as well that the pair $(\Pow (X),\subseteq)$ (for a given
        set $X$) is a partial order.

        Next, recall that given a poset $(X, \leq_X)$ we were able to define a
        new poset $(X_\bot, \leq)$. Thus prove that the latter is indeed a
        poset.  Finally given two sets $X$ and $Y$ prove that the set $[X,Y]$
        of maps between $X$ and $Y$ is a poset whenever $Y$ is a poset.
\end{problem}

Let us now go beyond posets and shift our attention to $\omega$-CPOs. We start
by revisiting the previous problem from the latter's perspective.

\begin{problem}
        Consider a set $\mathrm{State}$ of states. Show that it is an
        $\omega$-CPO when it comes equipped with equality as the partial order.
        Show as well that the pair $(\Pow (X),\subseteq)$ (for a given set $X$)
        is an $\omega$-CPO.

        Next, recall that given an $\omega$-CPO $(X, \leq_X)$ we were able to
        define a new $\omega$-CPO $(X_\bot, \leq)$. Thus prove that the latter
        is indeed an $\omega$-CPO.  Finally given two sets $X$ and $Y$ prove
        that the set $[X,Y]$ of maps between $X$ and $Y$ is a $\omega$-CPO
        whenever $Y$ is an $\omega$-CPO.
\end{problem}

Another key notion for defining the interpretation of while-loops was that of a
\emph{continuous} map $f : X \to Y$ (between $\omega$-CPOs $X$ and $Y$). Just
to recall, a map $f$ is called continuous if it satisfies the following
conditions.
\begin{flalign*}
        x_1 \leq x_2 & \text{ entails } f(x_1) \leq f(x_2) \qquad (\text{for all $x_1,x_2 \in X$ })
        \\
        f(\vee_n x_n) & = \vee_n f(x_n) \qquad 
        (\text{for every monotone sequence $(x_n)_{n \in \Nats}$}) 
\end{flalign*}

\begin{problem}
        Prove that the composition $g \comp f : X \to Z$ of continuous maps
        $f : X \to Y$ and $g : Y \to Z$ is continuous.
\end{problem}

These last three problems contain some of the necessary ingredients to
interpret while-loops as fixpoints. Another ingredient is Kleene's fixpoint
theorem which tells us how to build (the least) fixpoint of a continuous map $f
: X \to X$ on an $\omega$-CPO $X$ with a bottom element. The fixpoint (denoted
by $\mathrm{lfp}\, f$) is explicitly built as,
\[
        \mathrm{lfp}\, f = \vee_{n \in \Nats}\, f^n(\bot)
\]
\begin{problem}
        Show that $\mathrm{lfp}\, f$ is indeed the least fixpoint of $f$.
\end{problem}

Finally after some work we obtained the denotational semantics detailed in
Figure~\ref{fig:denot}.

        \begin{figure}[h]
        \begin{minipage}{1\textwidth}
        \begin{flalign*}
                \sem{\prog{x : = e}} & = \sigma \mapsto \sigma[\sem{\prog{e}}/\prog{x}] \\[2pt]
                \sem{\prog{p} \> \blue{ ;} \> \prog{q}} & 
                = \sem{\prog{q}} \comp \sem{\prog{p}} \\[5pt]
                \sem{\mathtt{\blue{ if} \> b \> \blue{ then} \> p \> \blue{ else} \> q}}
                                                        & 
                                                        = [\sem{\prog{p}},\sem{\prog{q}}] \comp
                                                        \mathrm{dist} \comp \pv{\sem{\prog{b}}}{\id}
                                                        \\[5pt]
                \sem{\mathtt{\blue{ while} \> b \> \blue{ do } \> \{ \> p \> \}} }
                                                        & \> {=} \> \mathrm{lfp}\ \Big (k \mapsto
                [k \comp 
                \sem{\prog{p}},\id] \comp
                \mathrm{dist} \comp \pv{\sem{\prog{b}}}{\id} \Big )
        \end{flalign*}
        \end{minipage}
        \caption{A denotational semantics for the while-language}
        \label{fig:denot}
        \end{figure}


\section{Axiomatic Semantics}

\end{document}
